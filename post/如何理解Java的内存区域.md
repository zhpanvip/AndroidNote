Java 的内存主要可以分为五大部分，分别为：方法区、Java 虚拟机栈、本地方法栈、程序计数器，以及堆内存。要说这几块内存不能分开了谈，而是应该通过虚拟机执行字节码的过程来看。

Java虚拟机在执行某个方法前，一定会先将这个方法所在的类加载到虚拟机中。因此，就需要一个特定的区域来存储这个类的信息，包括类中的常量、静态变量、以及即时编译器编译后的代码等数据，那么这一个区域就被称为方法区。

方法区的限制非常宽松，因此也就导致了不同的虚拟机上方法区有不同的表现。我们以HotSpot虚拟机为例：**方法区在JDK1.7之前是一块单独的区域**，很多人喜欢把它称为“永久代”（Permanent Generation），但本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展到了方法区，或者说**使用永久代来实现了方法区**。这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存。但是对于其它虚拟机（如BEA JRockit、IBM J9等）来说其实是不存在永久代的概念的。用永久代来实现方法区并不是一个好主意，因为这样更容易出现内存溢出的问题。而HotSpot的团队显然也意识到了这点问题，因此，在JDK1.7中将方法区中的字符串常量池移到了堆内存中，并在JDK1.8中完全废除了“永久代”，使用元空间替代了永久代。


Java虚拟机以方法作为最基本的执行单元，在虚拟机执行方法的过程中，每个方法都会被封装成一个栈帧。栈帧是Java虚拟机栈的基本组成元素。当一份方法被调用时，JVM 就会创建一个对应的栈帧，并将该栈帧压入到当前线程的虚拟机栈中。当方法执行完成时，对应的栈帧就会被销毁。

存储栈帧的任务栈就是Java虚拟机栈。简单的说虚拟机在执行方法时，会把方法的调用链上的所有方法都封装成对应的栈帧，并压入栈中，然后从栈顶开始执行栈帧，执行完成之后会将该栈帧弹出，然后执行下一个栈帧，直到任务栈中的所有栈帧都出栈为止。

栈帧的结构主要分为4类，分别为局部变量表、操作数栈、动态链接、方法返回地址。

- 局部变量表存储了方法参数和参数内部定义的局部变量。
- 操作数栈用于存储计算过程中的中间结果和临时数据。
- 动态链接是栈帧中指向运行时常量池的引用。
- 方法返回地址保存了方法执行完后控制流应该返回的位置信息。

如果方法中存在实例化对象的代码，那么实例化后的对象并不会存储在虚拟机栈中，而是存储在Java的堆内存中，栈内存的栈帧中只存储了对象的引用。堆内存除了存放Java对象外，在JDK7之后，运行时常量池也被放到了堆内存中。

我们知道，对于单核的CPU来说可以同时并发执行多个进程。这一操作是靠CPU的时间片轮转机制实现的，即通过将CPU时间花费成微小的片段，并循环分配给就绪的任务。如果同时有两个进程在并发执行，那么当CPU在处理第一个进程时，第二个进程就会处于wait状态，同理，当CPU切换到第二个进程时，第一个进程就会处于wait状态。当进程处于wait时，意味着进程中的线程也是处于wait状态，那么线程在执行的方法时就需要记录当前方法指令执行的位置，以便再次切回到就绪状态后能够继续从当前位置执行。因此，就需要有一个单独的程序计数器来标记执行的指令的位置。

除了Java虚拟机栈外，虚拟机中还有一个本地方法栈，这块内存区域的作用与Java虚拟机栈类似，区别在于本地方法栈用来执行的是 native 方法。

相关参考链接：

[Java运行时内存区域详解](https://juejin.cn/post/6868340872698658830)



